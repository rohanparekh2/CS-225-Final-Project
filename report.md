	We’ve played pokemon for our entire childhood so we decided that it would be a fun idea to use pokemon as our dataset for this project. We believe that the pokemon community should have a convenient way of searching through the different pokemon from all the generations from various categories like height, weight, type, Pokedex number, etc. From this dataset and the algorithms we created within our project, we can see if there are any correlations between the different categories of pokemon. By default, Pokemon websites are only organized by ID, with our algorithms we are able to do this and much more such as organizing pokemon between multiple groups and even visualizing this.
	Within this project we were able to create three major algorithms. These include Breadth-first search, Iterative deepening depth-first search, and finally Force-directed graph drawing.To create the Breadth-first search, or more commonly called BFS, we created Vertices and Edges classes that would be used by a class called Graph, which includes all of the algorithms. These Vertices contain the Pokedex number ID and the Edges were used to link these Vertices together. BFS is used to find the shortest distance between two Vertices via Edges and combining this with Pokemon, we can find the shortest distance between two Pokemon.
	The next algorithm we implemented is the Iterative deepening depth-first search, or more commonly known as IDDFS. IDDFS combines both DFS and BFS so that IDDFS has the efficiency of DFS and BFS’ fast search. To implement it we created a method that checks if we could visit a certain node within a certain amount of iterations. IDDFS always starts at the starting node even after other nodes have already been visited. This makes it have a longer runtime than BFS and DFS, but the upper levels normally do not take much time to go through.
	The final algorithm that we decided to make was the force-directed graph. We created an algorithm that split the pokemon into different groups, more particularly based upon their generations and their status. Then we colored the graph based on the type of the pokemon. This means there were eight different sections in the graph that corresponded to each generation Each section contained a plethora of colors because there are eighteen different pokemon types that are represented in almost every generation. All of the common pokemon were in their own section, and the mythical and legendary pokemon had their own smaller sections.
	For our final results, we were able to create a graph that could give us helpful information about the differences between Pokemon from each generation. We can traverse through the graph using our BFS and IDDFS algorithms to find pokemon that share categories with a pokemon from a completely different game. For example, if we wanted to find a Pokemon similar to Pikachu from a different generation, we could easily search through the graph and find Thundurus, which is an electric type just like Pikachu. This would help us reach our goal of finding the similarities and differences between the many generations of pokemon. The force-directed graph is also a helpful tool because it is a visual representation of the Pokemon of each generation and all of their types and species. There were also many variables that we decided not to use including height, weight, and catch rate. This could have made the graph even more detailed and complex. Overall, we were able to use the dataset to give insight about how Pokemon has changed over the years.
